# A0142102E
###### \java\seedu\tasklist\commons\util\RecurringUtil.java
``` java
package seedu.tasklist.commons.util;

import java.util.Calendar;
import java.util.Date;

public class RecurringUtil {
	
	public static Calendar updateRecurringDate(Calendar toUpdate, String frequency, int value) {
		if (!toUpdate.getTime().equals(new Date(0))) {
		    switch (frequency) {
		    case "daily": toUpdate.add(Calendar.DAY_OF_YEAR, value); break;
		    case "weekly": toUpdate.add(Calendar.WEEK_OF_YEAR, value); break;
		    case "monthly": toUpdate.add(Calendar.MONTH, value); break;
		    case "yearly": toUpdate.add(Calendar.YEAR, value); break;
		    }
		}
		return toUpdate;
	}
}
```
###### \java\seedu\tasklist\logic\commands\ShowCommand.java
``` java
package seedu.tasklist.logic.commands;

import java.util.List;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

/**
 * Shows all tasks that fulfill the category keyword.
 * Keyword matching is case insensitive.
 */
public class ShowCommand extends Command {

	public static final String COMMAND_WORD = "show";

	public static final String MESSAGE_USAGE = COMMAND_WORD + ": Shows all tasks under the requested category. "
			+ "The specified keywords (case-insensitive) are shown as a list with index numbers.\n"
			+ "Parameters: KEYWORD (all, incomplete, complete, p/[PRIORITY]\n"
			+ "Example: " + COMMAND_WORD + " all";

	public static final String MESSAGE_SHOW_FAILURE = "Invalid category. Available categories: all, incomplete, complete, p/[PRIORITY], or a date";
	public static final String MESSAGE_SUCCESS = "Shown requested tasks.";
	private final String keyword;

	public ShowCommand(String keyword) {
		this.keyword = keyword;
	}

	@Override
	public CommandResult execute() {

		switch (keyword) {

		case "all":
			model.updateFilteredListToShowAll(); break;

		case "incomplete":
			model.updateFilteredListToShowIncomplete(); break;

		case "complete": case "done":
			model.updateFilteredListToShowComplete(); break;

		case "p/high": case "p/med": case "p/low":
			model.updateFilteredListToShowPriority(keyword); break;

		case "floating":
			model.updateFilteredListToShowFloating(); break;

		case "overdue":
			model.updateFilteredListToShowOverDue(); break;
			
		case "recurring":
			model.updateFilteredListToShowRecurring(); break;

		default:
			List<DateGroup> dates = new Parser().parse(keyword);
			if(dates.isEmpty()){
				return new CommandResult(String.format(MESSAGE_SHOW_FAILURE));
			}
			else{
				model.updateFilteredListToShowDate(keyword);
			}
		}
		return new CommandResult(String.format(getMessageForTaskListShownSummary(model.getFilteredTaskList().size())));
	}
}
```
###### \java\seedu\tasklist\model\ModelManager.java
``` java

    @Override
    public boolean isOverlapping(Task task) {
    	return taskList.isOverlapping(task);
    }
    
    @Override
    public void updateFilteredListToShowComplete() {
        updateFilteredListToShowAll();
        updateFilteredTaskList(new PredicateExpression(new CompletedQualifier()));
    }

    @Override
    public void updateFilteredListToShowRecurring() {
        updateFilteredListToShowAll();
        updateFilteredTaskList(new PredicateExpression(new RecurringQualifier()));
    }

    @Override
    public void updateFilteredListToShowOverlapping(Task task) {
        updateFilteredListToShowAll();
        updateFilteredTaskList(new PredicateExpression(new OverlappingQualifier(task)));
    }

    @Override
    public void updateFilteredListToShowPriority(String priority) {
        updateFilteredListToShowAll();
        updateFilteredTaskList(new PredicateExpression(new PriorityQualifier(priority)));
    }
    
    @Override
    public void updateFilteredListToShowDate(String date) {
        updateFilteredListToShowAll();
        updateFilteredTaskList(new PredicateExpression(new DateQualifier(date)));
    }
``` 
###### \java\seedu\tasklist\model\ModelManager.java   
``` java
 
    private class CompletedQualifier implements Qualifier {
        @Override
        public boolean run(ReadOnlyTask person) {
            return person.isComplete();
        }
    }

    private class PriorityQualifier implements Qualifier {
        private String priority;

        public PriorityQualifier(String priority) {
            this.priority = priority.replaceFirst("p/", "");
        }

        @Override
        public boolean run(ReadOnlyTask person) {
            return person.getPriority().priorityLevel.equals(this.priority);
        }
    }

    private class DateQualifier implements Qualifier {
        private final Calendar requestedTime;

        public DateQualifier(String time) {
            requestedTime = Calendar.getInstance();
            List<DateGroup> dates = new Parser().parse(time);
            requestedTime.setTime(dates.get(0).getDates().get(0));
        }

        @Override
        public boolean run(ReadOnlyTask person) {
            return DateUtils.isSameDay(person.getStartTime().time, requestedTime)
                    || (person.getStartTime().toCardString().equals("-")
                            && DateUtils.isSameDay(person.getEndTime().time, requestedTime));
        }
    }

    private class RecurringQualifier implements Qualifier {
        @Override
        public boolean run(ReadOnlyTask person) {
            return person.isRecurring();
        }
    }
    
    private class OverlappingQualifier implements Qualifier {
        private Task task;
    	
    	public OverlappingQualifier(Task task) {
            this.task = task;
        }
    	
    	@Override
        public boolean run(ReadOnlyTask person) {

    		// Overlapping task is task w/start only and compared task is an event
    		if (task.getEndTime().toCardString().equals("-") && !person.getEndTime().toCardString().equals("-")) {
    			return !task.getStartTime().toCardString().equals("-")
    					&& !person.getStartTime().toCardString().equals("-")
    					&& !task.getStartTime().getAsCalendar().after(person.getEndTime().getAsCalendar())
    					&& !person.getStartTime().getAsCalendar().after(task.getStartTime().getAsCalendar());
    		}
    		
    		// Overlapping task is an event and compared task is task w/start only DONE
    		else if (!task.getEndTime().toCardString().equals("-") && person.getEndTime().toCardString().equals("-")) {
    			return !person.getStartTime().toCardString().equals("-")
    					&& !task.getStartTime().getAsCalendar().after(person.getStartTime().getAsCalendar())
    					&& !task.getEndTime().getAsCalendar().before(person.getStartTime().getAsCalendar());
    		}
    		
    		// Compare 2 events DONE
    		else if (!task.getEndTime().toCardString().equals("-") && !person.getEndTime().toCardString().equals("-")) {
    			return !person.getStartTime().toCardString().equals("-")
    					&& !task.getStartTime().getAsCalendar().after(person.getStartTime().getAsCalendar())
    					&& !person.getStartTime().getAsCalendar().after(task.getEndTime().getAsCalendar());
    		}
    		
    		// Compare 2 tasks w/start only DONE
    		return task.getStartTime().getAsCalendar().equals(person.getStartTime().getAsCalendar());
        }
    }
```
###### \java\seedu\tasklist\model\task\Task.java
``` java

	public void setRecurringTime() {
	    if (isRecurring && !this.recurringFrequency.equals("")) {
	    	if (isComplete) {
	    		RecurringUtil.updateRecurringDate(startTime.time, recurringFrequency, 1);
	    		RecurringUtil.updateRecurringDate(endTime.time, recurringFrequency, 1);
	    	}
	    	
	        if (!startTime.isMissing() || !endTime.isMissing()) {
	            isComplete = false;
	        }
	    }
	}
```
###### \java\seedu\tasklist\model\task\Task.java
``` java

	@Override
	public int compareTo(Task o) {
		// compare floating tasks
		if (this.startTime.equals(o.getStartTime()) && this.endTime.equals(o.getEndTime())) {
			return this.priority.compareTo(o.getPriority());
		}
		else {
			if (this.startTime.equals(o.getStartTime())) {
			    return this.endTime.compareTo(o.getEndTime());
			}
			else if (this.endTime.equals(o.getEndTime())) {
			    return this.startTime.compareTo(o.getStartTime());
			}
			// if only has end time
			else if(this.startTime.toCardString().equals("-")) {
			    return this.endTime.compareTo(o.getStartTime());
			}
			else if (o.getStartTime().toCardString().equals("-")){
			    return this.startTime.compareTo(o.getEndTime());
			}
			// if only has start time
			else {
			    return this.startTime.compareTo(o.getStartTime());
			}
		}
	}
```