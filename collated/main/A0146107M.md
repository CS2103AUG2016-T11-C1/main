# A0146107M
###### \java\seedu\tasklist\commons\events\model\TaskCountersChangedEvent.java
``` java
public class TaskCountersChangedEvent extends BaseEvent {

    public final TaskCounter data;

    public TaskCountersChangedEvent(TaskCounter data){
        this.data = data;
    }

    @Override
    public String toString() {
        return "Counters updated!";
    }

}
```
###### \java\seedu\tasklist\commons\events\TickEvent.java
``` java
public class TickEvent extends BaseEvent {

	@Override
	public String toString() {
		return "1s tick";
	}
}
```
###### \java\seedu\tasklist\logic\commands\DeleteCommand.java
``` java
package seedu.tasklist.logic.commands;

import java.util.HashSet;
import java.util.Set;

import seedu.tasklist.commons.core.Messages;
import seedu.tasklist.commons.core.UnmodifiableObservableList;
import seedu.tasklist.model.task.ReadOnlyTask;
import seedu.tasklist.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Deletes a person identified using its last displayed index or name from the address
 * book.
 */
public class DeleteCommand extends Command {

	public static final String COMMAND_WORD = "delete";

	public static final String MESSAGE_USAGE = COMMAND_WORD
			+ ": Deletes the task identified by the index number used in the last task listing.\n"
			+ "Parameters: either INDEX (must be a positive integer) or TASKNAME\n" + "Example: " + COMMAND_WORD + " 1";

	public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";
	public static final String MESSAGE_DELETE_TASK_FAILURE = "No such task was found.";
	public static final String MESSAGE_DELETE_IN_NEXT_STEP = "Multiple tasks were found containing the entered keywords."
			+ " Please check below and delete by index.";

	public final boolean deleteByIndex;

	public int targetIndex;
	public String taskName;


    /**
     * Constructor using targetIndex.
     * 
     * @param	targetIndex index of task to be deleted
     */
	public DeleteCommand(int targetIndex) {
		deleteByIndex = true;
		this.targetIndex = targetIndex-1;
	}
	
    /**
     * Constructor using taskName.
     * 
     * @param	taskName name of task to be deleted
     */
	public DeleteCommand(String taskName) {
		deleteByIndex = false;
		taskName = taskName.trim();
		this.taskName = taskName;
	}

	/**
     * Executes the command
     */
	@Override
	public CommandResult execute(){
		if(deleteByIndex){
			return deleteUsingIndex();
		}
		else{
			return deleteUsingString();
		}	
	}

	/**
     * Processes the deletion of tasks by string
     * 
     * @return CommandResult containing task deletion outcome
     */
	private CommandResult deleteUsingString(){
		UnmodifiableObservableList<ReadOnlyTask> matchingTasks = getFilteredTaskList();
		String returnValue;
		switch(matchingTasks.size()){
		case 0:
			model.updateFilteredListToShowIncomplete();
			returnValue = String.format(MESSAGE_DELETE_TASK_FAILURE);
			break;
		case 1:
			String details = deleteTask(matchingTasks.get(0));
			returnValue = String.format(MESSAGE_DELETE_TASK_SUCCESS, details);
			break;
		default:
			returnValue = String.format(MESSAGE_DELETE_IN_NEXT_STEP);
		}
		return new CommandResult(returnValue);
	}

    /**
     * Gets filtered tasklist for deletion by string
     * 
     * @return UnmodifiableObservableList containing tasks whose name contain the given string
     */
	private UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList(){
		Set<String> taskNameSet = new HashSet<String>();
		taskNameSet.add(taskName);
		model.updateFilteredTaskList(taskNameSet);
		return model.getFilteredTaskList();
	}


    /**
     * Processes the deletion of tasks by index
     * 
     * @return CommandResult containing task deletion outcome
     */
	private CommandResult deleteUsingIndex(){
		UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
		if(targetIndex >= lastShownList.size()){
			return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
		}
		else{
			String details = deleteTask(lastShownList.get(targetIndex));
			return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, details));
		}
	}
	
    /**
     * Deletes task from model
     * 
     * @param taskToDelete the task to be deleted
     * @return String containing details of the deleted task
     */
	private String deleteTask(ReadOnlyTask taskToDelete){
		try {
			model.deleteTask(taskToDelete);
		}
		catch (TaskNotFoundException e) {
			assert false: "The target task cannot be missing";
		}
		return taskToDelete.getTaskDetails().toString();
	}
}
```
###### \java\seedu\tasklist\logic\LogicManager.java
``` java
	@Override
	public TaskCounter getTaskCounter() {
		return model.getTaskCounter();
	}
}
```
###### \java\seedu\tasklist\logic\parser\ArgumentParser.java
``` java
/**
 * Parses an input string to extract arguments.
 * 
 */
public class ArgumentParser {
	private HashMap<String, String> subArgs;

	/**
     * Constructor
     * 
     * @param	input user input
     * @param	keywords array of keywords
     */
	public ArgumentParser(String input, String[] keywords){
		//Initialise data structures
		subArgs = new HashMap<String, String>();
		HashMap<String, Integer> locales = new HashMap<String, Integer>();
		subArgs.put("default", "");
		locales.put("default", 0);
		//insert keywords into hashmaps
		for(String keyword: keywords){
			subArgs.put(keyword.trim(), "");
			//max value indicates not found
			locales.put(keyword, Integer.MAX_VALUE);
		}
		//parse input
		parse(locales, input);
	}

	/**
     * Get argument with a specific keyword
     * 
     * @param	arg keyword to be checked
     * @returns argument associated with keyword, null if none exists
     */
	public String getField(String arg){
		return (subArgs.get(arg)=="")?null:subArgs.get(arg);
	}

	/**
     * Get default argument
     * 
     * @returns the default argument, null if none exists
     */
	public String getField(){
		return getDefault();
	}

	/**
     * Get argument associated with keyword group
     * 
     * @returns the argument associated with keyword group, null if none exists
     */
	public String getEitherField(String...args){
		String result = null;
		for(String arg: args){
			if(getField(arg)!=null){
				result = getField(arg);
			}
		}
		return result;
	}

	/**
     * Get default argument
     * 
     * @returns the default argument, null if none exists
     */
	public String getDefault(){
		return (subArgs.get("default")=="")?null:subArgs.get("default");
	}

	/**
     * Extract index from input string
     * 
     * @returns the integer that starts the input string, null if none exists
     */
	public static Integer extractIndex(String input){
		try{
			return Integer.valueOf(input.split(" ")[0]);
		}
		catch(NumberFormatException nfe){
			return null;
		}
	}

	/**
     * Extract index from input string
     * 
     * @returns the integer that starts the input string, null if none exists, or if string contains other arguments
     */
	public static Integer extractIndexBlocking(String input){
		if (input.split(" ").length>1){
			return null;
		}
		else{
			try{
				return Integer.valueOf(input.split(" ")[0]);
			}
			catch(NumberFormatException nfe){
				return null;
			}
		}
	}

	/**
     * Remove index from input string
     * 
     * @param input A string starting with an index
     * @returns The input string, less the index
     */
	public static String cutIndex(String input){
		String result = "";
		//split by spaces
		String[] tokens = input.split(" ");
		//remove first token (the index)
		for(int i=1; i<tokens.length; i++){
			result += tokens[i] + " ";
		}
		return result.trim();
	}

	/**
     * Retrieves arguments from input string and puts them into subArgs
     * 
     */
	private void parse(HashMap<String, Integer> locales, String input){
		//iterate by character
		for(int i=0; i<input.length(); i++){
			//check all keywords
			for(String arg: locales.keySet()){
				//check if keyword exists at character index i
				if(isArg(i, arg, input)){
					//insert into locales
					locales.put(arg, i);
					//remove keyword from string
					input = input.replaceFirst(arg, "");
				}
			}
		}
		getArgsFromLocales(locales, input);
	}

	/**
     * Retrieves arguments from input string given locales
     * 
     */
	private void getArgsFromLocales(HashMap<String, Integer> locales, String input){
		ArrayList<Map.Entry<String, Integer>> locs = new ArrayList<Map.Entry<String, Integer>>();
		addArgLocales(locales, locs);
		Collections.sort(locs, (a,b)->{return a.getValue()-b.getValue();});

		retrieveArgs(locs, input);
	}

	/**
     * Helper method for getArgsFromLocales
     * 
     */
	private void retrieveArgs(ArrayList<Map.Entry<String, Integer>> locs, String input){
		Iterator<Map.Entry<String, Integer>> iter = locs.iterator();
		//get first item
		Map.Entry<String, Integer> next = iter.next();
		int start, end;
		String arg;

		do{
			//starts at index of current keyword
			start = next.getValue();
			//get keyword
			arg = next.getKey();
			if(iter.hasNext()){
				next = iter.next();
				//ends at index of next keyword
				end = next.getValue();
			}
			else{
				//ends at end of string
				end = input.length();
			}
			//stores argument
			subArgs.put(arg.trim(), input.substring(start, end));
		} while(end != input.length());
	}

	/**
     * Adds all present keywords into locs
     * 
     */
	private void addArgLocales(HashMap<String, Integer> locales, ArrayList<Map.Entry<String, Integer>> locs){
		for(Map.Entry<String, Integer> locale: locales.entrySet()){
			//check if keyword is present
			if(locale.getValue()!=Integer.MAX_VALUE){
				locs.add(locale);
			}
		}
	}

	/**
     * Check if keyword starts the input string
     * 
     * @return true if keyword starts the input string
     */
	private boolean isArg(int index, String arg, String input){
		if(index<0 || index>=input.length()){
			return false;
		}
		else{
			return input.substring(index).startsWith(arg);
		}
	}
}
```
###### \java\seedu\tasklist\logic\parser\Parser.java
``` java
	private static final String[] ADD_TASK_KEYWORDS = {" at ", " by ", " from ", " to ", " r/", " p/", " t/"};

	private static final String[] UPDATE_TASK_KEYWORDS = {" at ", " by ", " from ", " to ", " r/"," p/", " t/"};
```
###### \java\seedu\tasklist\logic\parser\TimePreparser.java
``` java
/**
 * Checks input for dates in dd/mm/yyyy format and converts it to mm/dd/yyyy
 * 
 */
public class TimePreparser {
	
	private static Pattern wrongDate = Pattern.compile("\\d*[/.-]\\d*([/.-]\\d*)?");
	private static Pattern dateType = Pattern
			.compile("(?<day>[012][0-9]|3[01])[/.-](?<month>[0]?[1-9]|1[012])([/.-](?<year>(19|20)\\d\\d))?");

	/**
	 * Checks input for dates in dd/mm/yyyy format and converts it to mm/dd/yyyy
	 * 
	 * @param	input String to be checked
	 */
	public static String preparse(String input) {
		//split string into tokens
		String[] tokens = input.split(" ");
		String result;
		if (tokens.length >= 1) {
			//parse all tokens
			result = parseAllTokens(tokens);
		} 
		else {
			result = tokens[0];
		}
		return result.trim();
	}

	/**
	 * Checks all tokens for dates in dd/mm/yyyy format and converts it to mm/dd/yyyy.
	 * 
	 * @param	tokens Strings to be checked
	 * @return	string with all tokens joined together, wrongdate if an invalid date was present
	 */
	private static String parseAllTokens(String[] tokens){
		//create empty result string
		String result = "";
		//interate through all tokens
		for (String token : tokens) {
			//parse token
			String parsedToken = checkTokenForDate(token);
			//check if token is invalid date
			if(parsedToken.equals("wrongdate")){
				result = parsedToken;
				return result;
			}
			else{
				//append to result
				result +=  parsedToken + " ";
			}
		}
		return result;
	}

	/**
	 * Checks token for date in dd/mm/yyyy format and converts it to mm/dd/yyyy,
	 * 
	 * @param	token String to be checked
	 * @return	the converted String, wrongdate if an invalid date was entered
	 */
	private static String checkTokenForDate(String token){
		//Matcher for dates
		Matcher matcher = dateType.matcher(token);
		//Matcher for dd/dd/dddd, where d is a digit
		Matcher wrongMatcher = wrongDate.matcher(token);
		//check if is valid date
		if (matcher.matches()) {
			//rearrange date
			token = rearrangeDate(matcher);
		}
		//check if is not valid date && is dd/dd/dddd => invalid date
		else if(wrongMatcher.matches()){
			//return a string that will cause Natty Parser to fail
			return "wrongdate";
		}
		//return rearranged token
		return token;
	}

	/**
	 * Rearranges date from dd/mm/yyyy to mm/dd/yyyy,
	 * 
	 * @param	matcher The matcher containing the date components
	 * @return	The converted String
	 */
	private static String rearrangeDate(Matcher matcher){
		return matcher.group("month") + "/" + matcher.group("day") + "/"
				+ ((matcher.group("year")==null)?"":matcher.group("year"));
	}

}
```
###### \java\seedu\tasklist\MainApp.java
``` java
    private void initThread(){
    	updateThread = new Thread(){
    		public void run(){
				long timeToNextMinute = 60 - Calendar.getInstance().get(Calendar.SECOND);
				try {
					Thread.sleep(timeToNextMinute*1000);
    				while (true) {
						Platform.runLater(() -> {
							EventsCenter.getInstance().post(new TickEvent());
						});
						Thread.sleep(60 * 1000);
					}
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
    		}
    	};
    	updateThread.start();
    }
```
###### \java\seedu\tasklist\model\ModelManager.java
``` java
	private final TaskCounter taskCounter;
```
###### \java\seedu\tasklist\model\ModelManager.java
``` java
	@Subscribe
	private void tickEvent(TickEvent te) {
		indicateTaskListChanged();
	}
```
###### \java\seedu\tasklist\model\ModelManager.java
``` java
	@Override
	public TaskCounter getTaskCounter(){
		return taskCounter;
	}
	/** Raises an event to indicate a task has been modified */
	private void indicateTaskModified(ReadOnlyTask task) {
		raise(new TaskModifiedEvent(task));
	}

	/** Raises an event to indicate the model has changed */
	private void indicateTaskListChanged() {
		raise(new TaskListChangedEvent(taskList));
	}


```
###### \java\seedu\tasklist\model\ModelManager.java
``` java
	private class NameQualifier implements Qualifier {
		private Set<String> nameKeyWords;
		private Pattern NAME_QUERY;

		NameQualifier(Set<String> nameKeyWords) {
			this.nameKeyWords = nameKeyWords;
			this.NAME_QUERY = Pattern.compile(getRegexFromString(), Pattern.CASE_INSENSITIVE);
		}

		private String getRegexFromString() {
			String result = "";
			for (String keyword : nameKeyWords) {
				for (char c : keyword.toCharArray()) {
					switch (c) {
					case '*':
						result += ".*";
						break;
					default:
						result += c;
					}
				}
			}
			return result;
		}

		@Override
		public boolean run(ReadOnlyTask person) {
			Matcher matcher = NAME_QUERY.matcher(person.getTaskDetails().taskDetails);
			return matcher.matches();
		}
```
###### \java\seedu\tasklist\model\task\EndTime.java
``` java
/**
* Represents the start time of a task.
* 
*/
public class EndTime extends Time{

    public static final String MESSAGE_END_TIME_CONSTRAINTS = "End time is invalid!";
    public static final int DEFAULT_HOUR_VAL = 23;
    public static final int DEFAULT_MINUTE_VAL = 59;

    /**
     * Constructor using natural language input
     *
     * @param input Input string to parse
     * @throws IllegalValueException if given start time is invalid.
     */
    public EndTime(String input) throws IllegalValueException {
    	super(input);
    }
    
    /**
     * Constructor using unix time millis
     *
     * @param unixTimeMillis Input long representing time in millis since epoch time
     */
    public EndTime(Long unixTimeMillis) {
    	super(unixTimeMillis);
    }
    
    /**
     * Constructor using a Calendar instance
     *
     * @param cal Calendar to get time info from
     */ 
    public EndTime(Calendar cal) {
    	super(cal);
    }
    
    /**
     * Get hour default
     *
     * @return the default hour value
     */
    @Override
	protected int getDefaultHourVal(){
    	return DEFAULT_HOUR_VAL;
    }

    /**
     * Get minute default
     *
     * @return the default minute value
     */
    @Override
	protected int getDefaultMinuteVal(){
    	return DEFAULT_MINUTE_VAL;
    }
    
    /**
     * Get Illegal Value Exception message
     *
     * @return The message associated with an Illegal Value Exception
     */
    @Override
    protected String getIVEMessage(){
    	return MESSAGE_END_TIME_CONSTRAINTS;
    }

    /**
     * Checks if another object is equal to this EndTime instance
     *
     * @param other Another object to compare to
     * @return true if both are EndTime objects and the time represented by both objects are equal
     */
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof EndTime // instanceof handles nulls
                && this.time.getTimeInMillis()==((EndTime) other).time.getTimeInMillis()); // state check
    }

    /**
     * Get a hash representation of this object
     *
     * @return The hash representation of this object
     */
    @Override
    public int hashCode() {
        return super.hashCode();
    }

}
```
###### \java\seedu\tasklist\model\task\StartTime.java
``` java
/**
 * Represents the start time of a task.
 * 
 */
public class StartTime extends Time{

    public static final String MESSAGE_START_TIME_CONSTRAINTS = "Start time is invalid!";
    public static int DEFAULT_HOUR_VAL = 0;
    public static int DEFAULT_MINUTE_VAL = 0;

    /**
     * Constructor using natural language input
     *
     * @param input Input string to parse
     * @throws IllegalValueException if given start time is invalid.
     */
    public StartTime(String input) throws IllegalValueException {
    	super(input);
    }
    
    /**
     * Constructor using unix time millis
     *
     * @param unixTimeMillis Input long representing time in millis since epoch time
     */
    public StartTime(Long unixTimeMillis) {
    	super(unixTimeMillis);
    }
    
    /**
     * Constructor using a Calendar instance
     *
     * @param cal Calendar to get time info from
     */ 
    public StartTime(Calendar cal){
    	super(cal);
    }

    /**
     * Get hour default
     *
     * @return the default hour value
     */
    @Override
	protected int getDefaultHourVal(){
    	return DEFAULT_HOUR_VAL;
    }

    /**
     * Get minute default
     *
     * @return the default minute value
     */
    @Override
	protected int getDefaultMinuteVal(){
    	return DEFAULT_MINUTE_VAL;
    }
    
    /**
     * Get Illegal Value Exception message
     *
     * @return The message associated with an Illegal Value Exception
     */
    @Override
    protected String getIVEMessage(){
    	return MESSAGE_START_TIME_CONSTRAINTS;
    }
    
    /**
     * Checks if another object is equal to this StartTime instance
     *
     * @param other Another object to compare to
     * @return true if both are StartTime objects and the time represented by both objects are equal
     */
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof StartTime // instanceof handles nulls
                && this.time.getTimeInMillis()==((StartTime) other).time.getTimeInMillis()); // state check
    }

    /**
     * Get a hash representation of this object
     *
     * @return The hash representation of this object
     */
    @Override
    public int hashCode() {
        return super.hashCode();
    }

}
```
###### \java\seedu\tasklist\model\task\Time.java
``` java
/**
 * Represents time.
 * 
 */
public class Time {

    public static final String MESSAGE_TIME_CONSTRAINTS = "Time is invalid!";
    public static final Date EPOCH_TIME = new Date(0);

    public Calendar time;

    /**
     * Constructor using NLP
     *
     * @param input Input string to parse
     * @throws IllegalValueException if given time is invalid.
     */
    public Time(String input) throws IllegalValueException {
    	//initialize time
    	time = Calendar.getInstance();
    	//check if input string is null
    	if(input == null || input==""){
    		//set to epoch time
    		time.setTime(EPOCH_TIME);
    	}
    	else{
    		parseTimeInNlp(time, input);
    	}
    	clearTimeSeconds();
    }
    
    /**
     * Parse time using Natty Parser NLP
     *
     * @param time Calendar to update
     * @param input String to parse
     * @throws IllegalValueException if given time is invalid.
     */
    private void parseTimeInNlp(Calendar time, String input) throws IllegalValueException{
    	//parse inputs
    	String preparsedTime = TimePreparser.preparse(input);
		List<DateGroup> dates = new Parser().parse(preparsedTime);
		//check if date is invalid
		if(dateNotPresent(dates)){
			throw new IllegalValueException(getIVEMessage());
		}
		//set time
		else{
			time.setTime(dates.get(0).getDates().get(0));
			setDefaultTime(dates.get(0));
		}
    }
    
    /**
     * Check if Natty Parser finds a date in a string
     *
     * @param dates List of DateGroups generated by Natty Parser after parsing a string
     * @return true if no date is found, false if a date is found
     */
    private boolean dateNotPresent(List<DateGroup> dates){
    	return dates.isEmpty() || dates.get(0).getDates().isEmpty();
    }
    
    /**
     * Clear the second and millisecond fields from the Time object
     *
     */
    private void clearTimeSeconds(){
    	time.clear(Calendar.SECOND);
    	time.clear(Calendar.MILLISECOND);
    }
    
    /**
     * Constructor using unix time in millis
     *
     * @param unixTimeMillis A long indicating the number of milliseconds since Unix epoch
     */
    public Time(Long unixTimeMillis) {
    	time = Calendar.getInstance();
    	time.setTimeInMillis(unixTimeMillis);
    }
    
    /**
     * Constructor using a Calendar instance
     *
     * @param cal Calendar to get time info from
     */ 
    public Time(Calendar cal){
    	time = (Calendar)cal.clone();
    }
    
    /**
     * Updates time based on NLP input
     *
     * @param input String representing time
     * @throws IllegalValueException if given time is invalid
     */
    public void updateTime(String input) throws IllegalValueException {
    	//check if it is a new time field
    	if(time.getTime().equals(EPOCH_TIME)){
    		Time temp = new Time(input);
    		this.time = temp.time;
    	}
    	//it is an update of a previously declared time
    	else{
    		//parse inputs
    		String preparsedTime = TimePreparser.preparse(input);
    		List<DateGroup> dates = new Parser().parse(preparsedTime);
    		//check if Natty finds any dates in input string
    		if(dateNotPresent(dates)){
    			throw new IllegalValueException(getIVEMessage());
    		}
    		//date present
    		else{
    			DateGroup dateGroup = dates.get(0);
    			//update times
    			updateAppropriateFields(dateGroup);
    		}
    	}
    }
    
    
    /**
     * Update time's appropriate fields based on parsed input
     *
     * @param dateGroup DateGroup returned by Natty Parser
     */
    private void updateAppropriateFields(DateGroup dateGroup){
    	//get time read by Natty Parser
    	Calendar reference = Calendar.getInstance();
    	reference.setTime(dateGroup.getDates().get(0));
    	//if time is explicitly defined, update time
		if(!dateGroup.isTimeInferred()){
			time.set(Calendar.HOUR_OF_DAY, reference.get(Calendar.HOUR_OF_DAY));
			time.set(Calendar.MINUTE, reference.get(Calendar.MINUTE));
		}
		//if date is explicitly defined, update date
		if(!dateGroup.isDateInferred()){
			time.set(Calendar.DAY_OF_MONTH, reference.get(Calendar.DAY_OF_MONTH));
			time.set(Calendar.MONTH, reference.get(Calendar.MONTH));
			time.set(Calendar.YEAR, reference.get(Calendar.YEAR));
		}
    }
    
    /**
     * Set time to default values
     *
     * @param dateGroup dategroup returned by Natty Parser
     */
    private void setDefaultTime(DateGroup dateGroup){
    	if (dateGroup.isTimeInferred()) {
			time.set(Calendar.HOUR_OF_DAY, getDefaultHourVal());
			time.set(Calendar.MINUTE, getDefaultMinuteVal());
		}
    }
    
    /**
     * Get hour default
     *
     * @return the default hour value
     */
    protected int getDefaultHourVal(){
    	return 0;
    }

    /**
     * Get minute default
     *
     * @return the default minute value
     */
    protected int getDefaultMinuteVal(){
    	return 0;
    }
    
    /**
     * Get Illegal Value Exception message
     *
     * @return The message associated with an Illegal Value Exception
     */
    protected String getIVEMessage(){
    	return MESSAGE_TIME_CONSTRAINTS;
    }
    
    /**
     * Get a string representation of the object
     *
     * @return the string representation of the Time object
     */
    @Override
    public String toString() {
    	if(time.getTime().equals(new Date(0))){
    		return (new Date(0)).toString();
    	}
    	else{
    		return time.getTime().toString();
    	}
    }
    
    /**
     * Get a string representation of the object, with epoch time represented as "-"
     *
     * @return the string representation of the Time object
     */
    public String toCardString() {
    	if(time.getTime().equals(new Date(0))){
    		return "-";
    	}
    	else{
    		DateFormat df = new SimpleDateFormat("d MMM yyyy\n  h:mm a");
    		String finalString = df.format(time.getTime());
    		
    		return finalString;
    	}
    }

    /**
     * Get a string representation of the object, with epoch time represented as "-"
     *
     * @return the string representation of the Time object
     */   
    public String toDateString() {
        if(time.getTime().equals(new Date(0))){
            return "-";
        }
        else{
            DateFormat df = new SimpleDateFormat("d MMM yyyy h:mm a");
            String finalString = df.format(time.getTime());
            
            return finalString;
        }
    }
    
    /**
     * Checks if time is equal to epoch time
     *
     * @return true if time represented by this object is epoch time
     */
    public boolean isMissing(){
    	return time.getTime().equals(EPOCH_TIME);
    } 
    
    /**
     * Checks if another object is equal to this Time instance
     *
     * @param other Another object to compare to
     * @return true if both are Time objects and the time represented by both objects are equal
     */
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Time
                && this.time.getTimeInMillis()==((Time) other).time.getTimeInMillis()); // state check
    }

    /**
     * Get a hash representation of this object
     *
     * @return The hash representation of this object
     */
    @Override
    public int hashCode() {
        return time.hashCode();
    }
    
    /**
     * Get the Calendar object associated with this Time object
     *
     * @return The calendar object associated with this Time object
     */
    public Calendar getAsCalendar() {
        return time;
    }

    /**
     * Compares this Time object with another Time object
     *
     * @param time The other Time object to compare to
     * @return 0 if both times are equal, positive if the time represented by this object is 
     * after the time of the compared object, negative if the time represented by this object is
     * before the time of the compared object
     */
    public int compareTo(Time time) {
    	Long time1 = this.getAsCalendar().getTimeInMillis();
    	Long time2 = time.getAsCalendar().getTimeInMillis();
    	return time1.compareTo(time2);
    }

}
```
###### \java\seedu\tasklist\model\task\UniqueID.java
``` java
import org.apache.commons.lang.StringUtils;

import seedu.tasklist.commons.exceptions.IllegalValueException;

/**
 * Represents a Person's address in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidAddress(String)}
 */
public class UniqueID {

    public final String value;

    /**
     * Validates given address.
     *
     * @throws IllegalValueException if given address string is invalid.
     */
    public UniqueID(String address) throws IllegalValueException {
        assert StringUtils.isNumeric(address);
        this.value = address;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueID // instanceof handles nulls
                && this.value.equals(((UniqueID) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### \java\seedu\tasklist\model\TaskCounter.java
``` java
/**
 * Counts the numbers of each type of task
 *
 */
public class TaskCounter {

	private int total;
	private int floating;
	private int overdue;
	private int tomorrow;
	private int today;
	private int other;
	private int upcoming;
	
	
	/**
	 * Constructor with ReadOnlyTaskList
	 * 
	 * @param src ReadOnlyTaskList containing initial data
	 */
	public TaskCounter(ReadOnlyTaskList src){
		//set values to 0
		reinitializeValues();
		//count tasks
		setCountersToList(src.getTaskList());
		//listen for events
		EventsCenter.getInstance().registerHandler(this);
		//indicate taskcounter has changed
		EventsCenter.getInstance().post(new TaskCountersChangedEvent(this));
	}
	
	/**
	 * Handler for TaskListChangedEvent
	 * 
	 * @param tlce TaskListChangedEvent containing new list
	 */
    @Subscribe
    private void modelChangedEvent(TaskListChangedEvent tlce) {
    	//reset counters
    	reinitializeValues();
    	//re-count tasks
    	setCountersToList(tlce.data.getTaskList());
    	//indicate taskcounter has changed
    	EventsCenter.getInstance().post(new TaskCountersChangedEvent(this));
    }
    
	/**
	 * Increments counters based on given list of tasks
	 * 
	 * @param taskList List of tasks to be counted
	 */
    private void setCountersToList(List<ReadOnlyTask> taskList){
    	for(ReadOnlyTask task: taskList){
    		incrementCounters(task);
    	}
    }
    
	/**
	 * Increments counters based on given task
	 * 
	 * @param task Task to be counted
	 */
    private void incrementCounters(ReadOnlyTask task){
    	total++;
    	if(task.isFloating()){
    		floating++;
    	}
    	else if(task.isEvent() && !task.isOverDue()){
    		upcoming++;
    	}
    	else {
    		other++;
    	}
    	
    	if(task.isOverDue()){
    		overdue++;
    	}
    	else if(task.isTomorrow()){
    		tomorrow++;
    	}
    	else if(task.isToday()){
    		today++;
    	}
    }
    
	/**
	 * Resets all counters
	 * 
	 */
    private void reinitializeValues(){
    	 this.total = 0;
    	 this.floating = 0;
    	 this.overdue = 0;
    	 this.tomorrow = 0;
    	 this.today = 0;
    	 this.other = 0;
    	 this.upcoming = 0;
    }
    
    /**
	 * Get total number of tasks
	 * 
	 * @return total number of tasks
	 */
	public int getTotal() {
		return total;
	}

    /**
	 * Get number of floating tasks
	 * 
	 * @return number of floating tasks
	 */
	public int getFloating() {
		return floating;
	}

    /**
	 * Get number of overdue tasks
	 * 
	 * @return number of overdue tasks
	 */
	public int getOverdue() {
		return overdue;
	}

    /**
	 * Get number of tasks starting tomorrow
	 * 
	 * @return number of tasks starting tomorrow
	 */
	public int getTomorrow() {
		return tomorrow;
	}

    /**
	 * Get number of tasks starting today
	 * 
	 * @return number of tasks starting today
	 */
	public int getToday() {
		return today;
	}

    /**
	 * Get number of other tasks
	 * 
	 * @return number of other tasks
	 */
	public int getOther() {
		return other;
	}

    /**
	 * Get number of upcoming events
	 * 
	 * @return number of upcoming events
	 */
	public int getUpcoming() {
		return upcoming;
	}	
}
```
###### \java\seedu\tasklist\model\TaskList.java
``` java
    public void updateTask(Task taskToUpdate, TaskDetails taskDetails, String startTime, String endTime,
            Priority priority, String recurringFrequency) throws IllegalValueException {
        if (taskDetails != null) 
            taskToUpdate.setTaskDetails(taskDetails); 
        if (startTime != null) 
            taskToUpdate.getStartTime().updateTime(startTime); 
        if (endTime != null) 
            taskToUpdate.getEndTime().updateTime(endTime);
        if (priority != null)
            taskToUpdate.setPriority(priority);
        if (recurringFrequency != null)
            taskToUpdate.setRecurringFrequency(recurringFrequency);
    }
```
###### \java\seedu\tasklist\storage\XmlAdaptedTask.java
``` java
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getTaskDetails().taskDetails;
        startTime = Long.toString(source.getStartTime().time.getTimeInMillis());
        endTime = Long.toString(source.getEndTime().time.getTimeInMillis());
        priority = source.getPriority().priorityLevel;
        recurringFrequency = source.getRecurringFrequency();
        isComplete = String.valueOf(source.isComplete());
/*        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }*/
    }

    /**
     * Converts this jaxb-friendly adapted person object into the model's Person object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted person
     */
    public Task toModelType() throws IllegalValueException {
      /*  final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }*/
        final TaskDetails name = new TaskDetails(this.name);
        final StartTime startTime = new StartTime(Long.valueOf(this.startTime));
        final EndTime endTime = new EndTime(Long.valueOf(this.endTime));
        final Priority priority = new Priority(this.priority);
      //  final UniqueTagList tags = new UniqueTagList(taskTags);

        final boolean isComplete = Boolean.valueOf(this.isComplete);
        Task newTask = new Task(name, startTime, endTime, priority, recurringFrequency);
        if(isComplete){
        	newTask.markAsComplete();
        }
        return newTask;
    }
}
```
###### \java\seedu\tasklist\ui\CategoryPanel.java
``` java
/**
 * Panel containing the list of persons.
 */
public class CategoryPanel extends UiPart {
    private final Logger logger = LogsCenter.getLogger(CategoryPanel.class);
    private static final String FXML = "CategoryPanel.fxml";
    private AnchorPane gridpane;
    private AnchorPane placeHolderPane;

    @FXML
    private Label overdueNo;
    @FXML
    private Label todayNo;
    @FXML
    private Label tomorrowNo;
    @FXML
    private Label floatingNo;
    @FXML
    private Label otherNo;
    @FXML
    private Label totalNo;
    @FXML
    private Label upcomingNo;
    
    
    
    public CategoryPanel() {
        super();
    }
    
    @Override
    public void setNode(Node node) {
    	gridpane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static CategoryPanel load(Stage primaryStage, AnchorPane personListPlaceholder, TaskCounter taskCounter) {
        CategoryPanel categoryPanel =
                UiPartLoader.loadUiPart(primaryStage, personListPlaceholder, new CategoryPanel());
        categoryPanel.configure();
        categoryPanel.setCounts(taskCounter);
        EventsCenter.getInstance().registerHandler(categoryPanel);
        return categoryPanel;
    }
    
    @Subscribe
    private void countsChangedEvent(TaskCountersChangedEvent data) {
    	setCounts(data.data);
    }
    
    private void setCounts(TaskCounter newCounts) {
    	overdueNo.setText(Integer.toString(newCounts.getOverdue()));
    	todayNo.setText(Integer.toString(newCounts.getToday()));
    	tomorrowNo.setText(Integer.toString(newCounts.getTomorrow()));
    	floatingNo.setText(Integer.toString(newCounts.getFloating()));
    	otherNo.setText(Integer.toString(newCounts.getOther()));
    	totalNo.setText(Integer.toString(newCounts.getTotal()));
    	upcomingNo.setText(Integer.toString(newCounts.getUpcoming()));
    }
    
    private void configure() {
    	gridpane.setStyle("-fx-background-color: #FFFFFF;");
        addToPlaceholder();
    }

    private void setConnections() {
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(gridpane);
    }
}
```
###### \java\seedu\tasklist\ui\CommandBox.java
``` java
	private Stack<String> upStack;
	private Stack<String> downStack;
	private String currHistLine;
	private boolean hasTempEnd;

	String[] commands = {"add", "done", "update", "delete", "show", "find", "exit"
			, "undo", "redo", "help", "clear", "setstorage"};
```
###### \java\seedu\tasklist\ui\CommandBox.java
``` java
	public void configure(ResultDisplay resultDisplay, Logic logic) {
		this.resultDisplay = resultDisplay;
		this.logic = logic;
		configureKeyEvents();
		upStack = new Stack<String>();
		downStack = new Stack<String>();
		commandTextField.requestFocus();
		registerAsAnEventHandler(this);
	}

	private void configureKeyEvents(){
		commandTextField.setOnKeyPressed(new EventHandler<KeyEvent>() {
			public void handle(final KeyEvent keyEvent) {
				switch(keyEvent.getCode()){
				case UP:
					handleButtonUp(keyEvent.isControlDown());
					keyEvent.consume();
					break;
				case DOWN:
					handleButtonDown(keyEvent.isControlDown());
					keyEvent.consume();
					break;
				case SPACE: case TAB:
					autoComplete();
					keyEvent.consume();
					break;
				default:
					break;
				}
			}
		});
	}
	
	private void handleButtonUp(boolean isControlDown){
		if(isControlDown){
			EventsCenter.getInstance().post(new TaskListScrollEvent(TaskListPanel.Direction.UP));
		}
		else{
			getUpLine();
		}
	}
	
	private void handleButtonDown(boolean isControlDown){
		if(isControlDown){
			EventsCenter.getInstance().post(new TaskListScrollEvent(TaskListPanel.Direction.DOWN));
		}
		else{
			getDownLine();
		}
	}
	
	private void getUpLine(){
		if(!upStack.isEmpty()){
			if(downStack.isEmpty()){
				hasTempEnd = true;
			}
			downStack.push(commandTextField.getText());
			currHistLine = upStack.pop();
			commandTextField.setText(currHistLine);
			commandTextField.end();
		}
	}

	private void getDownLine(){
		if(!downStack.isEmpty()){
			upStack.push(commandTextField.getText());
			currHistLine = downStack.pop();
			commandTextField.setText(currHistLine);
			commandTextField.end();
		}
	}

	private void autoComplete(){
		String currentString = commandTextField.getText();
		String completedCommand = commandTextField.getText();
		boolean found = false;
		for (String command: commands){
			if (command.startsWith(currentString)){
				if(found){
					return;
				}
				else{
					completedCommand = command;
					found = true;
				}
			}
		}
		if(!found){
			return;
		}
		else{
			commandTextField.setText(completedCommand);
			commandTextField.end();
		}
	}

	private void addToPlaceholder() {
		SplitPane.setResizableWithParent(placeHolderPane, false);
		placeHolderPane.getChildren().add(commandTextField);
		FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);
		FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);
	}
```
###### \java\seedu\tasklist\ui\CommandBox.java
``` java
		if(!downStack.isEmpty()){
			upStack.push(currHistLine);
			while(!downStack.isEmpty()){
				upStack.push(downStack.pop());
			}
			if(hasTempEnd){
				upStack.pop();
				hasTempEnd = false;
			}
		}

		//Take a copy of the command text
		previousCommandTest = commandTextField.getText();

		/* We assume the command is correct. If it is incorrect, the command box will be changed accordingly
		 * in the event handling code {@link #handleIncorrectCommandAttempted}
		 */
		setStyleToIndicateCorrectCommand();
		upStack.push(previousCommandTest);
```
###### \java\seedu\tasklist\ui\HelpWindow.java
``` java
    private static final Logger logger = LogsCenter.getLogger(HelpWindow.class);
    private static final String ICON = "/images/help_icon.png";
    private static final String FXML = "HelpWindow.fxml";
    private static final String TITLE = "Help";
    private static final String USERGUIDE_URL = HelpWindow.class.getResource("/ug_html/CommandSummary.html")
            .toExternalForm();
```
###### \java\seedu\tasklist\ui\HelpWindow.java
``` java
        WebView browser = new WebView();
        browser.getEngine().load(USERGUIDE_URL);
        FxViewUtil.applyAnchorBoundaryParameters(browser, 0.0, 0.0, 0.0, 0.0);

        // dialogStage.setMaximized(false); //TODO: set a more appropriate
        // initial size
        setIcon(dialogStage, ICON);
        mainPane.getChildren().add(browser);

```
###### \java\seedu\tasklist\ui\TaskCard.java
``` java
	private void setPriorityGraphic(){
		switch(task.getPriority().priorityLevel){
		case "high":
			priority.setGraphic(new ImageView(getImage(PRIORITY_HIGH_FILE)));
			break;
		case "med":
			priority.setGraphic(new ImageView(getImage(PRIORITY_MED_FILE)));
			break;
		case "low":	default:
			priority.setGraphic(new ImageView(getImage(PRIORITY_LOW_FILE)));
			break;
		}
	}
	
	private void setRecurringGraphic(){
		switch(task.getRecurringFrequency()){
		case "daily":
			recurring.setGraphic(new ImageView(getImage(DAILY_RECUR_FILE)));
			break;
		case "weekly":
			recurring.setGraphic(new ImageView(getImage(WEEKLY_RECUR_FILE)));
			break;
		case "monthly":
			recurring.setGraphic(new ImageView(getImage(MONTHLY_RECUR_FILE)));
			break;
		case "yearly":
			recurring.setGraphic(new ImageView(getImage(YEARLY_RECUR_FILE)));
		default:
			break;
		}					
	}

	private void setColour(){
		if(task.isComplete()){
			cardPane.setStyle("-fx-background-color: #C0FFC0;");
		}
		else if(task.isOverDue()){
			cardPane.setStyle("-fx-background-color: #FFC0C0;");
		}
		else {
			cardPane.setStyle("-fx-background-color: #FFFFFF;");
		}
	}

	public void setStatusButtonColour() {
		if(task.isComplete()){
			statusButton.setImage(getImage(COMPLETED_ICON_FILE));
		}
		else if(task.isOverDue()){
			statusButton.setImage(getImage(OVERDUE_ICON_FILE));
		}
		else{
			statusButton.setImage(getImage(INCOMPLETE_ICON_FILE));
		}
	}

	private Image getImage(String resource){
		String url = TaskCard.class.getResource(IMAGE_DIR + resource).toExternalForm();
		return new Image(url);
	}

	@Override
	public void setNode(Node node) {
		cardPane = (AnchorPane)node;
	}

	@Override
	public String getFxmlPath() {
		return FXML;
	}
}
```
###### \java\seedu\tasklist\ui\TaskListPanel.java
``` java
	@Subscribe
	public void tickEventHandler(TickEvent te){
		personListView.refresh();
		setLabelText();
	}

	@Subscribe
	public void taskModifiedEventHandler(TaskModifiedEvent tme){
		personListView.scrollTo(tme.task);
		personListView.getSelectionModel().select(tme.task);
	}
	
	@Subscribe
	public void scrollEventHandler(TaskListScrollEvent tlse){
		scrollTraverse(tlse.dir);
	}
	
```
###### \java\seedu\tasklist\ui\TaskListPanel.java
``` java
		setLabelText();
		scrollPane.setFitToHeight(true);
		scrollPane.setFitToWidth(true);
		EventsCenter.getInstance().registerHandler(this);
```
###### \java\seedu\tasklist\ui\TaskListPanel.java
``` java
	public void scrollTraverse(Direction direction){
		int newIndex = personListView.getSelectionModel().getSelectedIndex();
		if(newIndex==-1){
			newIndex = 0;
		}
		else if(direction==Direction.UP){
			newIndex = Math.max(0, newIndex - 10);
		}
		else{
			newIndex = Math.min(personListView.getItems().size()-1, newIndex + 10);
		}
		scrollTo(newIndex);
	}

	public void scrollTo(int index) {
		Platform.runLater(() -> {
			personListView.scrollTo(index);
			personListView.getSelectionModel().clearAndSelect(index);
		});
	}

```
###### \resources\view\CategoryPanel.fxml
``` fxml

<AnchorPane maxWidth="370.0" minWidth="370.0" prefHeight="560.0" prefWidth="370.0" style="-fx-background-color: #DCF0EE;" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.tasklist.ui.CategoryPanel">
   <children>
      <VBox layoutY="24.0" maxHeight="560.0" prefHeight="536.0" style="-fx-background-color: #DCF0EE;" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
         <children>
            <GridPane prefHeight="560.0" prefWidth="370.0" style="-fx-background-color: #DCF0EE;">
              <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" maxWidth="276.0" minWidth="250.0" prefWidth="276.0" />
                <ColumnConstraints hgrow="SOMETIMES" maxWidth="120.0" minWidth="50.0" prefWidth="94.0" />
              </columnConstraints>
              <rowConstraints>
                  <RowConstraints minHeight="30.0" prefHeight="80.0" vgrow="SOMETIMES" />
                  <RowConstraints minHeight="30.0" prefHeight="80.0" vgrow="SOMETIMES" />
                  <RowConstraints minHeight="30.0" prefHeight="80.0" vgrow="SOMETIMES" />
                  <RowConstraints minHeight="30.0" prefHeight="80.0" vgrow="SOMETIMES" />
                <RowConstraints minHeight="30.0" prefHeight="80.0" vgrow="SOMETIMES" />
                <RowConstraints maxHeight="131.0" minHeight="30.0" prefHeight="78.0" vgrow="SOMETIMES" />
                <RowConstraints maxHeight="68.0" minHeight="7.0" prefHeight="30.0" vgrow="SOMETIMES" />
                  <RowConstraints maxHeight="121.0" minHeight="30.0" prefHeight="75.0" vgrow="SOMETIMES" />
              </rowConstraints>
               <children>
                  <Label prefHeight="36.0" prefWidth="146.0" stylesheets="@CategoryPanel.css" text="Overdue">
                     <font>
                        <Font size="25.0" />
                     </font>
                     <padding>
                        <Insets left="20.0" />
                     </padding>
                     <opaqueInsets>
                        <Insets />
                     </opaqueInsets>
                     <GridPane.margin>
                        <Insets left="38.0" />
                     </GridPane.margin>
                  </Label>
                  <Label fx:id="overdueNo" prefHeight="30.0" prefWidth="74.0" stylesheets="@CategoryPanel.css" text="0" GridPane.columnIndex="1">
                     <font>
                        <Font size="25.0" />
                     </font>
                     <GridPane.margin>
                        <Insets left="15.0" />
                     </GridPane.margin>
                  </Label>
                  <Label stylesheets="@CategoryPanel.css" text="Today" GridPane.rowIndex="1">
                     <font>
                        <Font size="25.0" />
                     </font>
                     <padding>
                        <Insets left="20.0" />
                     </padding>
                     <GridPane.margin>
                        <Insets left="40.0" />
                     </GridPane.margin>
                  </Label>
                  <Label stylesheets="@CategoryPanel.css" text="Tomorrow" GridPane.rowIndex="2">
                     <font>
                        <Font size="25.0" />
                     </font>
                     <padding>
                        <Insets left="20.0" />
                     </padding>
                     <GridPane.margin>
                        <Insets left="40.0" />
                     </GridPane.margin>
                  </Label>
                  <Label stylesheets="@CategoryPanel.css" text="Floating" GridPane.rowIndex="3">
                     <font>
                        <Font size="25.0" />
                     </font>
                     <padding>
                        <Insets left="20.0" />
                     </padding>
                     <GridPane.margin>
                        <Insets left="40.0" />
                     </GridPane.margin>
                  </Label>
                  <Label stylesheets="@CategoryPanel.css" text="Other Tasks" GridPane.rowIndex="4">
                     <font>
                        <Font size="25.0" />
                     </font>
                     <padding>
                        <Insets left="20.0" />
                     </padding>
                     <GridPane.margin>
                        <Insets left="38.0" />
                     </GridPane.margin>
                  </Label>
                  <Label id="total_tasks_label" stylesheets="@CategoryPanel.css" text="Total Tasks" textFill="RED" GridPane.rowIndex="5">
                     <font>
                        <Font size="25.0" />
                     </font>
                     <padding>
                        <Insets left="20.0" />
                     </padding>
                     <GridPane.margin>
                        <Insets left="40.0" />
                     </GridPane.margin>
                  </Label>
                  <Label id="upcoming_events_label" stylesheets="@CategoryPanel.css" text="Upcoming Events" textFill="#3700ff" GridPane.rowIndex="7">
                     <font>
                        <Font size="25.0" />
                     </font>
                     <padding>
                        <Insets left="20.0" />
                     </padding>
                     <GridPane.margin>
                        <Insets left="40.0" />
                     </GridPane.margin>
                  </Label>
                  <Label id="upcoming_events_label" fx:id="upcomingNo" prefHeight="30.0" prefWidth="74.0" stylesheets="@CategoryPanel.css" text="0" textFill="#1a00ff" GridPane.columnIndex="1" GridPane.rowIndex="7">
                     <font>
                        <Font size="25.0" />
                     </font>
                     <GridPane.margin>
                        <Insets left="15.0" />
                     </GridPane.margin>
                  </Label>
                  <Label id="total_tasks_label" fx:id="totalNo" prefHeight="30.0" prefWidth="74.0" stylesheets="@CategoryPanel.css" text="0" textFill="RED" GridPane.columnIndex="1" GridPane.rowIndex="5">
                     <font>
                        <Font size="25.0" />
                     </font>
                     <GridPane.margin>
                        <Insets left="15.0" />
                     </GridPane.margin>
                  </Label>
                  <Label fx:id="otherNo" prefHeight="30.0" prefWidth="74.0" stylesheets="@CategoryPanel.css" text="0" GridPane.columnIndex="1" GridPane.rowIndex="4">
                     <font>
                        <Font size="25.0" />
                     </font>
                     <GridPane.margin>
                        <Insets left="15.0" />
                     </GridPane.margin>
                  </Label>
                  <Label fx:id="floatingNo" prefHeight="30.0" prefWidth="74.0" stylesheets="@CategoryPanel.css" text="0" GridPane.columnIndex="1" GridPane.rowIndex="3">
                     <font>
                        <Font size="25.0" />
                     </font>
                     <GridPane.margin>
                        <Insets left="15.0" />
                     </GridPane.margin>
                  </Label>
                  <Label fx:id="tomorrowNo" prefHeight="30.0" prefWidth="74.0" stylesheets="@CategoryPanel.css" text="0" GridPane.columnIndex="1" GridPane.rowIndex="2">
                     <font>
                        <Font size="25.0" />
                     </font>
                     <GridPane.margin>
                        <Insets left="15.0" />
                     </GridPane.margin>
                  </Label>
                  <Label fx:id="todayNo" prefHeight="30.0" prefWidth="74.0" stylesheets="@CategoryPanel.css" text="0" GridPane.columnIndex="1" GridPane.rowIndex="1">
                     <font>
                        <Font size="25.0" />
                     </font>
                     <GridPane.margin>
                        <Insets left="15.0" />
                     </GridPane.margin>
                  </Label>
                  <ImageView fitHeight="52.0" fitWidth="47.0" pickOnBounds="true" preserveRatio="true">
                     <image>
                        <Image url="@../images/redclock.png" />
                     </image>
                  </ImageView>
                  <ImageView fitHeight="34.0" fitWidth="35.0" pickOnBounds="true" preserveRatio="true" GridPane.rowIndex="1">
                     <image>
                        <Image url="@../images/today.png" />
                     </image>
                     <GridPane.margin>
                        <Insets left="8.0" />
                     </GridPane.margin>
                  </ImageView>
                  <ImageView fitHeight="38.0" fitWidth="36.0" pickOnBounds="true" preserveRatio="true" GridPane.rowIndex="2">
                     <image>
                        <Image url="@../images/tomorrow.png" />
                     </image>
                     <GridPane.margin>
                        <Insets left="8.0" />
                     </GridPane.margin>
                  </ImageView>
                  <ImageView fitHeight="37.0" fitWidth="37.0" pickOnBounds="true" preserveRatio="true" GridPane.rowIndex="3">
                     <image>
                        <Image url="@../images/floating.png" />
                     </image>
                     <GridPane.margin>
                        <Insets left="8.0" />
                     </GridPane.margin>
                  </ImageView>
                  <ImageView fitHeight="41.0" fitWidth="42.0" pickOnBounds="true" preserveRatio="true" GridPane.rowIndex="4">
                     <image>
                        <Image url="@../images/upcoming.png" />
                     </image>
                     <GridPane.margin>
                        <Insets left="8.0" />
                     </GridPane.margin>
                  </ImageView>
                  <ImageView fitHeight="37.0" fitWidth="36.0" pickOnBounds="true" preserveRatio="true" GridPane.rowIndex="5">
                     <image>
                        <Image url="@../images/fantastical_icon.png" />
                     </image>
                     <GridPane.margin>
                        <Insets left="10.0" />
                     </GridPane.margin>
                  </ImageView>
                  <ImageView fitHeight="41.0" fitWidth="43.0" pickOnBounds="true" preserveRatio="true" GridPane.rowIndex="7">
                     <image>
                        <Image url="@../images/upcomingevent.png" />
                     </image>
                     <GridPane.margin>
                        <Insets left="10.0" />
                     </GridPane.margin>
                  </ImageView>
                  <Line endX="257.0" startX="-100.0" stroke="#80b0ff" GridPane.rowIndex="6" />
               </children>
               <VBox.margin>
                  <Insets />
               </VBox.margin>
            </GridPane>
         </children>
         <padding>
            <Insets top="0" />
         </padding>
      </VBox>
   </children>
</AnchorPane>
```
###### \resources\view\MainWindow.fxml
``` fxml

<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" style="-fx-background-color: #FFFFFF;" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.tasklist.ui.MainWindow">
   <children>

            <SplitPane id="splitPane" fx:id="splitPane" dividerPositions="0.5" style="-fx-background-color: white;" VBox.vgrow="ALWAYS">
         <items>
            <AnchorPane fx:id="categoryPanelPlaceholder" maxWidth="370.0" minWidth="370.0" prefWidth="370.0" style="-fx-background-color: white;">
                <padding>
                    <Insets bottom="10.0" left="10.0" right="2.0" top="10.0" />
                </padding>
            </AnchorPane>
            <VBox fx:id="personList" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" minWidth="340" prefHeight="20.0" prefWidth="1132.0" style="-fx-background-color: white;">
                <padding>
                    <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                </padding>
               <children>
                  <AnchorPane fx:id="personListPanelPlaceholder" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" VBox.vgrow="ALWAYS" />
               </children>
            </VBox>
         </items>
      </SplitPane>
      <VBox style="-fx-alignment: center;" VBox.vgrow="NEVER">
         <children>
             <AnchorPane fx:id="resultDisplayPlaceholder" maxHeight="200.0" minHeight="24.0" prefHeight="66.0" prefWidth="1504.0" style="-fx-background-color: white; -fx-border-color: white;" styleClass="anchor-pane-with-border">
                 <padding>
                     <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
                 </padding>
             </AnchorPane>
         </children>
      </VBox>
      <AnchorPane fx:id="commandBoxPlaceholder" style="-fx-background-color: white; -fx-border-color: white;" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
      <!--
      <AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
      -->
   </children>
</VBox>
```
###### \resources\view\TaskListPanel.fxml
``` fxml

<VBox maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="seedu.tasklist.ui.TaskListPanel">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
    <children>
      <ScrollPane fx:id="scrollPane" fitToHeight="true" fitToWidth="true" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" VBox.vgrow="ALWAYS">
        <content>
          <AnchorPane maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308">
               <children>
                  <VBox maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                     <children>
                        <HBox maxHeight="29.0" minHeight="29.0" prefHeight="29.0">
                           <children>
                              <ImageView fitHeight="29.0" fitWidth="37.0" pickOnBounds="true" preserveRatio="true">
                                 <image>
                                    <Image url="@../images/calendar-icon.png" />
                                 </image>
                              </ImageView>
                              <Label id="dateTimeLabel" fx:id="dateTimeLabel" maxWidth="1.7976931348623157E308" minWidth="363.0" prefHeight="30.0" prefWidth="533.0" text="Test" HBox.hgrow="ALWAYS">
                                 <padding>
                                    <Insets left="8.0" />
                                 </padding>
                              </Label>
                              <Label id="task_det" minWidth="83.0" prefHeight="30.0" prefWidth="92.0" text="Priority" />
                              <Label id="task_det" minWidth="84.0" prefWidth="110.0" text="Start" />
                              <Label id="task_det" minWidth="59.0" prefHeight="30.0" prefWidth="75.0" text="End" />
                           </children>
                        </HBox>
                          <ListView fx:id="personListView" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" VBox.vgrow="ALWAYS" />
                     </children>
                  </VBox>
               </children>
            </AnchorPane>
        </content>
      </ScrollPane>
    </children>
</VBox>
```
