package seedu.tasklist.model.task;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import seedu.tasklist.commons.exceptions.IllegalValueException;
import seedu.tasklist.logic.parser.TimePreparser;

import com.joestelmach.natty.*;

//@@author A0146107M
/**
 * Represents time.
 * 
 */
public class Time {

    public static final String MESSAGE_TIME_CONSTRAINTS = "Time is invalid!";
    public static final Date EPOCH_TIME = new Date(0);

    public Calendar time;

    /**
     * Constructor using NLP
     *
     * @param input Input string to parse
     * @throws IllegalValueException if given time is invalid.
     */
    public Time(String input) throws IllegalValueException {
    	//initialize time
    	time = Calendar.getInstance();
    	//check if input string is null
    	if(input == null || input==""){
    		//set to epoch time
    		time.setTime(EPOCH_TIME);
    	}
    	else{
    		parseTimeInNlp(time, input);
    	}
    	clearTimeSeconds();
    }
    
    /**
     * Parse time using Natty Parser NLP
     *
     * @param time Calendar to update
     * @param input String to parse
     * @throws IllegalValueException if given time is invalid.
     */
    private void parseTimeInNlp(Calendar time, String input) throws IllegalValueException{
    	//parse inputs
    	String preparsedTime = TimePreparser.preparse(input);
		List<DateGroup> dates = new Parser().parse(preparsedTime);
		//check if date is invalid
		if(dateNotPresent(dates)){
			throw new IllegalValueException(getIVEMessage());
		}
		//set time
		else{
			time.setTime(dates.get(0).getDates().get(0));
			setDefaultTime(dates.get(0));
		}
    }
    
    /**
     * Check if Natty Parser finds a date in a string
     *
     * @param dates List of DateGroups generated by Natty Parser after parsing a string
     * @return true if no date is found, false if a date is found
     */
    private boolean dateNotPresent(List<DateGroup> dates){
    	return dates.isEmpty() || dates.get(0).getDates().isEmpty();
    }
    
    /**
     * Clear the second and millisecond fields from the Time object
     *
     */
    private void clearTimeSeconds(){
    	time.clear(Calendar.SECOND);
    	time.clear(Calendar.MILLISECOND);
    }
    
    /**
     * Constructor using unix time in millis
     *
     * @param unixTimeMillis A long indicating the number of milliseconds since Unix epoch
     */
    public Time(Long unixTimeMillis) {
    	time = Calendar.getInstance();
    	time.setTimeInMillis(unixTimeMillis);
    }
    
    /**
     * Constructor using a Calendar instance
     *
     * @param cal Calendar to get time info from
     */ 
    public Time(Calendar cal){
    	time = (Calendar)cal.clone();
    }
    
    /**
     * Updates time based on NLP input
     *
     * @param input String representing time
     * @throws IllegalValueException if given time is invalid
     */
    public void updateTime(String input) throws IllegalValueException {
    	//check if it is a new time field
    	if(time.getTime().equals(EPOCH_TIME)){
    		Time temp = new Time(input);
    		this.time = temp.time;
    	}
    	//it is an update of a previously declared time
    	else{
    		//parse inputs
    		String preparsedTime = TimePreparser.preparse(input);
    		List<DateGroup> dates = new Parser().parse(preparsedTime);
    		//check if Natty finds any dates in input string
    		if(dateNotPresent(dates)){
    			throw new IllegalValueException(getIVEMessage());
    		}
    		//date present
    		else{
    			DateGroup dateGroup = dates.get(0);
    			//update times
    			updateAppropriateFields(dateGroup);
    		}
    	}
    }
    
    
    /**
     * Update time's appropriate fields based on parsed input
     *
     * @param dateGroup DateGroup returned by Natty Parser
     */
    private void updateAppropriateFields(DateGroup dateGroup){
    	//get time read by Natty Parser
    	Calendar reference = Calendar.getInstance();
    	reference.setTime(dateGroup.getDates().get(0));
    	//if time is explicitly defined, update time
		if(!dateGroup.isTimeInferred()){
			time.set(Calendar.HOUR_OF_DAY, reference.get(Calendar.HOUR_OF_DAY));
			time.set(Calendar.MINUTE, reference.get(Calendar.MINUTE));
		}
		//if date is explicitly defined, update date
		if(!dateGroup.isDateInferred()){
			time.set(Calendar.DAY_OF_MONTH, reference.get(Calendar.DAY_OF_MONTH));
			time.set(Calendar.MONTH, reference.get(Calendar.MONTH));
			time.set(Calendar.YEAR, reference.get(Calendar.YEAR));
		}
    }
    
    /**
     * Set time to default values
     *
     * @param dateGroup dategroup returned by Natty Parser
     */
    private void setDefaultTime(DateGroup dateGroup){
    	if (dateGroup.isTimeInferred()) {
			time.set(Calendar.HOUR_OF_DAY, getDefaultHourVal());
			time.set(Calendar.MINUTE, getDefaultMinuteVal());
		}
    }
    
    /**
     * Get hour default
     *
     * @return the default hour value
     */
    protected int getDefaultHourVal(){
    	return 0;
    }

    /**
     * Get minute default
     *
     * @return the default minute value
     */
    protected int getDefaultMinuteVal(){
    	return 0;
    }
    
    /**
     * Get Illegal Value Exception message
     *
     * @return The message associated with an Illegal Value Exception
     */
    protected String getIVEMessage(){
    	return MESSAGE_TIME_CONSTRAINTS;
    }
    
    /**
     * Get a string representation of the object
     *
     * @return the string representation of the Time object
     */
    @Override
    public String toString() {
    	if(time.getTime().equals(new Date(0))){
    		return (new Date(0)).toString();
    	}
    	else{
    		return time.getTime().toString();
    	}
    }
    
    /**
     * Get a string representation of the object, with epoch time represented as "-"
     *
     * @return the string representation of the Time object
     */
    public String toCardString() {
    	if(time.getTime().equals(new Date(0))){
    		return "-";
    	}
    	else{
    		DateFormat df = new SimpleDateFormat("d MMM yyyy\n  h:mm a");
    		String finalString = df.format(time.getTime());
    		
    		return finalString;
    	}
    }

    /**
     * Get a string representation of the object, with epoch time represented as "-"
     *
     * @return the string representation of the Time object
     */   
    public String toDateString() {
        if(time.getTime().equals(new Date(0))){
            return "-";
        }
        else{
            DateFormat df = new SimpleDateFormat("d MMM yyyy h:mm a");
            String finalString = df.format(time.getTime());
            
            return finalString;
        }
    }
    
    /**
     * Checks if time is equal to epoch time
     *
     * @return true if time represented by this object is epoch time
     */
    public boolean isMissing(){
    	return time.getTime().equals(EPOCH_TIME);
    } 
    
    /**
     * Checks if another object is equal to this Time instance
     *
     * @param other Another object to compare to
     * @return true if both are Time objects and the time represented by both objects are equal
     */
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Time
                && this.time.getTimeInMillis()==((Time) other).time.getTimeInMillis()); // state check
    }

    /**
     * Get a hash representation of this object
     *
     * @return The hash representation of this object
     */
    @Override
    public int hashCode() {
        return time.hashCode();
    }
    
    /**
     * Get the Calendar object associated with this Time object
     *
     * @return The calendar object associated with this Time object
     */
    public Calendar getAsCalendar() {
        return time;
    }

    /**
     * Compares this Time object with another Time object
     *
     * @param time The other Time object to compare to
     * @return 0 if both times are equal, positive if the time represented by this object is 
     * after the time of the compared object, negative if the time represented by this object is
     * before the time of the compared object
     */
    public int compareTo(Time time) {
    	Long time1 = this.getAsCalendar().getTimeInMillis();
    	Long time2 = time.getAsCalendar().getTimeInMillis();
    	return time1.compareTo(time2);
    }

}